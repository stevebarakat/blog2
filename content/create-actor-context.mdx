---
title: Using createActorContext to work with context
abstract: An example of using createActorContext to work with data.
publishedOn: 3
---

<div className="container">
In this excercise, we'll be re-creating the same example from the previous lesson, but we'll be using `createActorContext` to work with context instead. `createActorContext` is a helper function from the [@xstate/react](https://github.com/statelyai/xstate/tree/main/packages/xstate-react#readme/ "@xstate/react") package that creates a context object that can be used to store data in a state machine. Here's an example of a state machine that stores the current volume level in the context using `createActorContext`:

```ts
import { setup, assign, assertEvent } from "xstate";
import { createActorContext } from "@xstate/react";

export const machine = setup({
  types: {
    input: {} as { volume: number },
    context: {} as { volume: number },
    events: {} as
      | { type: "change.volume"; volume: number }
      | { type: "start" }
      | { type: "stop" },
  },
  actions: {
    "change.volume": assign(({ event }) => {
      assertEvent(event, "change.volume");
      return { volume: event.volume };
    }),
  },
}).createMachine({
  context: ({ input }) => ({
    volume: input?.volume,
  }),
  id: "Volume Machine",
  initial: "Stopped",
  on: {
    "change.volume": {
      actions: {
        type: "change.volume",
      },
    },
  },
  states: {
    Stopped: {
      on: {
        start: {
          target: "Playing",
        },
      },
    },
    Playing: {
      on: {
        stop: {
          target: "Stopped",
        },
      },
    },
  },
});

export const MachineContext = createActorContext(machine);
```

To use this machine in a React component, we can use the `useMachine` hook from `@xstate/react`:

```tsx
import { machine } from "./machine";
import { useMachine } from "@xstate/react";

function App() {
  const [state, send] = useMachine(machine);
  const { volume } = state.context;

  return (
    <div>
      <p>Volume: {volume}</p>
      <input
        type="range"
        value={volume}
        onChange={(e) =>
          send({ type: "change.volume", volume: e.target.valueAsNumber })
        }
      />
    </div>
  );
}

export default App;
```

As you can see, the `context` property in the machine definition is used to define the initial context of the machine. The `assign` action is used to update the context when the `change.volume` event is sent. The context is accessed in the React component using `state.context`. The volume level is displayed in a paragraph element, and an input element is used to change the volume level by sending the `change.volume` event with the new volume level. The state machine transitions between the "Stopped" and "Playing" states when the "start" and "stop" events are sent, respectively. Here's the state machine in action:

</div>

<CodeEditorProvider
  files={{
    starter: {
      "/App.js": {
        code: `import Volume from "./Volume";
import { MachineContext } from "./machine";

function App() {
  return (
    <MachineContext.Provider
      options={{
        input: {
          volume: 50,
        },
      }}
    >
      <Volume />
    </MachineContext.Provider>
  );
}

export default App;`,
      },
      "/Volume.js": {
        code: `import { MachineContext } from "./machine";

function Volume() {
  const { send } = MachineContext.useActorRef();
  const { volume } = MachineContext.useSelector((state) => state.context);

  return (
    <div>
      <p>Volume: {volume}</p>
      <input
        type="range"
        value={volume}
        onChange={(e) =>
          send({ type: "change.volume", volume: e.target.valueAsNumber })
        }
      />
    </div>
  );
}

export default Volume;`,
      },
      "/machine.ts": {
        code: `import { setup, assign, assertEvent } from "xstate";
import { createActorContext } from "@xstate/react";

export const machine = setup({
  types: {
    input: {} as { volume: number },
    context: {} as { volume: number },
    events: {} as
      | { type: "change.volume"; volume: number }
      | { type: "start" }
      | { type: "stop" },
  },
  actions: {
    "change.volume": assign(({ event }) => {
      assertEvent(event, "change.volume");
      return { volume: event.volume };
    }),
  },
}).createMachine({
  context: ({ input }) => ({
    volume: input?.volume,
  }),
  id: "Volume Machine",
  initial: "Stopped",
  on: {
    "change.volume": {
      actions: {
        type: "change.volume",
      },
    },
  },
  states: {
    Stopped: {
      on: {
        start: {
          target: "Playing",
        },
      },
    },
    Playing: {
      on: {
        stop: {
          target: "Stopped",
        },
      },
    },
  },
});

export const MachineContext = createActorContext(machine);
`,
      },
    },
  }}
/>

Play around with the code above to see how the state machine transitions between states when the button is clicked. Here are some excercises to try:

<div className="wrapper">
<ul>
  <li>Change the name of initial value of context to 25.</li>

  <li>Change the name context to "level."</li>
</ul>
</div>

## Context Exercise

In this excercise we'll be using what we learned last lesson and this lesson. We'll be creating a simple login form that stores the user's name in the state machine's context. The form will have two states: "Logged Out" and "Logged In." When the user is logged out, they will see a "Log In" button. When the user is logged in, they will see a "Log Out" button and a text input to enter their name.

Your instructions are as follows:

1. Create a new state machine called "Name Machine" and add the following states and events:

```ts
import { setup, assign, assertEvent } from "xstate";

export const machine = setup({
  types: {
    context: {} as { name: string },
    events: {} as
      | { type: "log.in" }
      | { type: "log.out" }
      | { type: "change.name"; name: string },
  },
  actions: {
    handleChangeName: assign(({ event }) => {
      assertEvent(event, "change.name");
      return { name: event.name };
    }),
  },
}).createMachine({
  context: {
    name: "",
  },
  id: "Name Machine",
  initial: "Logged Out",
  states: {
    "Logged Out": {
      on: {
        "log.in": {
          target: "Logged In",
        },
      },
    },
    "Logged In": {
      on: {
        "change.name": {
          actions: {
            type: "handleChangeName",
          },
        },
        "log.out": {
          target: "Logged Out",
        },
      },
    },
  },
});
```

2. Add a button to the "Logged Out" state that says "Log In" and a button to the "Logged In" state that says "Log Out." When the user clicks the "Log In" button, send the "log.in" event to the state machine. When the user clicks the "Log Out" button, send the "log.out" event to the state machine.

3. Add a text input to the "Logged In" state that allows the user to enter their name. When the user types in their name, send the "change.name" event with the name as the value of the event to the state machine.

4. Add a paragraph element to the "Logged In" state that displays the user's name from the state machine's context.

Here's the starter code:

<CodeEditorProvider files={
  { starter: {
  "/App.js": {
    code: `import { machine } from "./machine";
import { useMachine } from "@xstate/react";

function App() {
const isLoggedOut = true; // replace with machine state
return (

<>
  {isLoggedOut ? (
    <button>Log In</button>
  ) : (
    <>
      <button>Log Out</button>
      <div>
        <label htmlFor="name">Name: </label>
        <input id="name" />
      </div>
    </>
  )}
</>
); }

export default App;
`,
  },
  "/machine.ts": {
    active: true,
    code: `import { setup } from "xstate";

export const machine = setup({
  types: {
    events: {} as {},
  },
}).createMachine({
  initial: "",
  states: {},
});
`,
},
}, solution : {
  "/App.js": {
    code: `import { machine } from "./machine";
import { useMachine } from "@xstate/react";

function App() {
const [state, send] = useMachine(machine);
const { name } = state.context;
const isLoggedOut = state.matches("Logged Out");

return (

<>
  {isLoggedOut ? (
    <button onClick={() => send({ type: "log.in" })}>Log In</button>
  ) : (
    <>
      <button onClick={() => send({ type: "log.out" })}>Log Out</button>
      <div>
        <input
          placeholder="Name"
          value={name}
          onChange={(e) => send({ type: "change.name", name: e.target.value })}
        />
        <p>Name: {name}</p>
      </div>
    </>
  )}
</>
); }

export default App;
`,
  },
  "/machine.ts": {
    active: true,
    code: `import { assertEvent, assign, setup } from "xstate";

export const machine = setup({
  types: {
    context: {} as { name: string },
    events: {} as
      | { type: "log.in" }
      | { type: "log.out" }
      | { type: "change.name"; name: string },
  },
  actions: {
    handleChangeName: assign(({ event }) => {
      assertEvent(event, "change.name");
      return { name: event.name };
    }),
  },
}).createMachine({
  context: {
    name: "",
  },
  id: "Name Machine",
  initial: "Logged Out",
  states: {
    "Logged Out": {
      on: {
        "log.in": {
          target: "Logged In",
        },
      },
    },
    "Logged In": {
      on: {
        "change.name": {
          actions: {
            type: "handleChangeName",
          },
        },
        "log.out": {
          target: "Logged Out",
        },
      },
    },
  },
});
`,
},
}}} />
